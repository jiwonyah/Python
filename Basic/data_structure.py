"""
append(뭐시기) --> 데이터 구조 맨 끝에 요소 추가
insert(인덱스, 뭐시기) --> 특정 인덱스 위치에 뭐시기 추가

pop(인덱스) --> 해당 인덱스의 요소를 꺼냄 / 인자(인덱스)를 명시하지 않으면 가장 마지막 요소를 꺼냄.
a = eg.pop(3) --> eg의 세번째 요소였던 것이 a에 할당될 것임 + eg에서 3번째 인덱스가 빠짐.
remove(요소)

len(여기 안에 리스트나 뭐 그런거)

count(특정 요소) --> 데이터 구조 안의 특정 요소 개수 세기

sort(key, reverse) --> 순차 정렬? 거꾸로 정렬?  key는 정렬 기준 (len) --> 데이터 구조 자체를 변경
sorted(리스트) --> 새로운 리스트 생성. 즉, 원본 리스트는 변경되지 않음.

-----------------------------------------------------------------------------------------------

보통 데이터 구조 자체가 변하게 되는 경우 (clear, remove, append--> 비운다거나 지운다거나 추가한다거나 이런 건 모두 행위 자체이므로) 

print(example.clear()) --> 이런거의 출력은 None이 나오게 됨. 이유는? 해당 함수가 리스트 자체를 변경하지만 반환값은 없기 때문.

변환 후의 결과를 출력하고 싶다면,
example.clear()
print(example) 이 옳다.

--------------------------------------------------------------------------------------------------
Copy란 무엇인가? [리스트 편]

example = [1,2,3,[1,2]]
shallow_copy_example1 = example.copy()  --> 기본 내장함수 카피 (shallow copy)

import copy
shallow_copy_example2 = copy.copy(example) --> 모듈 copy의 내장함수 copy() (shallow copy)
deep_copy_example = copy.deepcopy(example) --> 모듈 copy의 내장함수 deepcopy() (deep copy)

* Shallow copy
  - 얕은 복사: 최상위 계층만 제대로 복사
  - 원본의 하위 계층이 변경되면 카피도 변경된다.
  - 원본의 최상위 계층의 변경은 카피에서 적용되지 않는다.
    ex) example[3][0] = 5   #example은 [1,2,3,[5,2]]
        print(shallow_copy_example1)   # [1,2,3,[5,2]]
  
* Deep copy
  - 깊은 복사: 재귀적 복사로 최하위 계층까지 복사
  - 원본의 최상위 계층 및 하위 계층을 포함한 모든 변경은 카피에서 적용되지 않는다.
    ex) example[3][0] = 5   #example은 [1,2,3,[5,2]]
        print(deep_copy_example)   # [1,2,3,[1,2]]
  
* '복사가 제대로 되었다' = '원본의 최상위 계층 변경은 카피에서 적용되지 않는다.' 
* 어떤 복사 방식이든 카피의 변경은 원본에 영향을 미치지 못한다.

---------------------------------------------------------------------------------------------

[Tuple]
리스트와 달리 불변형 객체임.
a = (1,2,3,[1,2])
튜플 자체를 변경하는 건 불가능하지만 튜플 내에 가변형 객체 (예: 리스트)가 있다면 해당 객체 내의 변경은 가능함.

e.g)
a[3][0] = 5 는 가능하지만
a[3] = [5,2] 는 불가능함.

"""

